# Permutation Feature Importance {#feature-importance}

{{< include _setup.qmd >}}

Permutation feature importance (PFI) measures the increase in the prediction error of the model after we permuted the feature's values, which breaks the relationship between the feature and the true outcome.

The concept is really straightforward:
We measure the importance of a feature by calculating the increase in the model's prediction error after permuting the feature.
A feature is "important" if shuffling its values increases the model error, because in this case the model relied on the feature for the prediction.
A feature is "unimportant" if shuffling its values leaves the model error unchanged, because in this case the model ignored the feature for the prediction.

## Theory

The permutation feature importance measurement was introduced by Breiman (2001)[@breiman2001random] for random forests.
Based on this idea, Fisher, Rudin, and Dominici (2018) [@fisher2019all] proposed a model-agnostic version of the feature importance and called it model reliance.
They also introduced more advanced ideas about feature importance, for example a (model-specific) version that takes into account that many prediction models may predict the data well.
Their paper is worth reading.

**The permutation feature importance algorithm based on Fisher, Rudin, and Dominici (2018):**

Input: Trained model $\hat{f}$, feature matrix $X$, target vector $y$, error measure $L(y,\hat{f})$.

1. Estimate the original model error $e_{orig} = L(y, \hat{f}(X))$  (e.g. mean squared error)
2. For each feature $j \in \{1,...,p\}$ do:
    - Generate feature matrix $X_{perm}$ by permuting feature j in the data X. This breaks the association between feature j and true outcome y.
    - Estimate error $e_{perm} = L(Y,\hat{f}(X_{perm}))$ based on the predictions of the permuted data.
    - Calculate permutation feature importance as quotient $FI_j= e_{perm}/e_{orig}$ or difference $FI_j = e_{perm}- e_{orig}$
3. Sort features by descending FI.


::: {.callout-tip}

You can also use PFI with metrics where larger is better, like accuracy or AUC.
Just make sure to swap roles of $e_{perm}$ and $e_{orig}$ in the ratio/difference. 

:::

Fisher, Rudin, and Dominici (2018) suggest in their paper to split the dataset in half and swap the values of feature j of the two halves instead of permuting feature j.
This is exactly the same as permuting feature j, if you think about it.
If you want a more accurate estimate, you can estimate the error of permuting feature j by pairing each instance with the value of feature j of each other instance (except with itself).
This gives you a dataset of size `n(n-1)` to estimate the permutation error, and it takes a large amount of computation time.
I can only recommend using the `n(n-1)` -method if you are serious about getting extremely accurate estimates.

::: {.callout-caution}

## Use test data for PFI 

Use test data to compute permutation feature importance.
The reason: PFI is based on error estimates and estimating errors using training data, we get overly optimistic results, especially when the model is overfitting.
Extreme scenario: A feature may have zero information about the target, but your model is completely overfitting using this feature.
In this case, PFI based on training data would show this feature to be very important.
But PFI based on test data would show the feature is irrelevant.

What if you want to know what the model actually **used**?
For that case we have better options such as [SHAP importance](#shap) or [PDP importance](#pdp) which don't rely on the error measure.

:::

In the examples, I used test data to compute permutation feature importance.

## Example and Interpretation

I show examples for classification and regression.

**Penguin male versus female classification**

We fit a random forest model to predict [penguin sex](#penguins), using 2/3 of the data for training, and 1/3 for computing the importance.
We measure the error as classification error.
Features associated with a model error increase by a factor of 1 (= no change) were not important for predicting penguin male vs. female.

```{r}
#| label: importance-penguins
#| fig-cap: !expr sprintf("The importance of each of the features for predicting penguin sex with a random forest. The most important feature was %s. Permuting %s resulted in an increase in classification error by a factor of %.1f. The interval indicates min and max importance from repeating the permutation 5 times, while dot represents the average PFI across multiple permutation.", most_imp, most_imp, max(imp.dat$importance))
predictor = Predictor$new(pengu_rf, data = penguins_test)
importance = FeatureImp$new(predictor, loss = "ce", compare="ratio")
imp.dat = data.frame(importance$results[c("feature", "permutation.error", "importance")])
most_imp = imp.dat$feature[imp.dat$importance == max(imp.dat$importance)]

plot(importance) +
  scale_x_continuous("Feature importance (classification error)", limits=c(0.5, NA)) +
   scale_y_discrete("") +
  my_theme()
```


**Bike sharing (regression)**

We fit a support vector machine model to predict [the number of rented bikes](#bike-data), given weather conditions and calendar information.
As error measurement we use the mean absolute error.

```{r}
predictor = Predictor$new(bike_svm, data = bike_test[-which(names(bike_test) == "cnt")], y = bike_test$cnt)
importance = FeatureImp$new(predictor, loss = 'mae')
imp.dat = importance$results
best = which(imp.dat$importance == max(imp.dat$importance))
worst = which(imp.dat$importance == min(imp.dat$importance))
```

```{r importance-bike, fig.cap = sprintf("The importance for each of the features in predicting bike counts with a support vector machine. The most important feature was %s, the least important was %s.", imp.dat$feature[best], imp.dat$feature[worst])}
plot(importance) +
   scale_y_discrete("") +
   scale_x_continuous(limits = c(1, NA))
```

## Conditional feature importance

Like all the model-agnostic methods, permutation feature importance has a problem when feature are dependent.
Shuffling produces unrealistic or at least unlikely data points, that are the used to compute feature importance -- not idea.
The problem is the *marginal* version of PFI ignores dependencies.
But there is also the concept of *conditional* importance.
The conditional version samples from the conditional distribution $P(X_j| X_{-j})$ instead of the marginal distribution $P(X_j)$ (shuffling is a way to sample from the marginal distribution).
By conditional sampling, we sample more realistic data point.

However, sampling from the conditional distribution is difficult.
It's an even more difficult task than our original machine learning task.
But it can be simplified by making assumptions such as assuming a feature is only linearly correlated with other features:
Here are some options for conditional sampling:

- Compute PFI in subgroups of the data and aggregate them. Subgroups are based on splitting in correlated features [@molnar2023modelagnostic].
- Use matching and imputation techniques to generate samples from the conditional distribution [@fisher2019all]
- Use knockoffs [@watson2021testing].
- For random forests there is a model-specific implementation [@strobl2008conditional,@debeer2020conditional], based on the original random forest importance [@breiman2001random]

Conditional feature importance has a different interpretation from marginal PFI:

- PFI measures the loss increase due to losing the feature information. 
- Conditional importance measures the loss increase due to losing the information *unique* to that feature, information not encoded in other features. 

Conditional importance can be a bit more difficult to interpret, since you also need an understanding how features are dependent on each other.
That's why I'm a big fan of the subgroups approach (and wrote a paper about it): Computing the PFI by group allows you to keep the marginal interpretation.

::: {.callout-warning}

Strongly dependent features usually have a very low conditional importance even when they are used by the model.

:::

## Group-wise PFI example

Let's go back to the penguins.
Since PFI of, e.g. body mass, is computed by permuting across all data, we mix weights from different penguin species.
But we can simply adapt PFI by splitting our data by species, and permuting for each subset separately, so that we get one PFI per feature AND species.
@fig-cor-by-species shows that we can reduce the correlation by subsetting by species.

```{r}
#| label: fig-cor-by-species
#| fig-cap: Correlation between body mass and flipper length by species subsets (and all together). Subsetting by species reduces the correlation.
penguins_by_species <- penguins %>%
  mutate(subset = "all") %>%
  bind_rows(penguins %>% mutate(subset = species))

cor_data <- penguins_by_species %>%
  group_by(subset) %>%
  dplyr::summarize(cor = cor(flipper_length_mm, body_mass_g, use = "complete.obs")) %>%
  mutate(cor_label = paste("r =", round(cor, 2)))

ggplot(penguins_by_species) + 
  geom_point(aes(x = flipper_length_mm, y = body_mass_g, color = species)) + 
  facet_wrap(~subset, scales = "free") + 
  geom_label(data = cor_data, aes(x = -Inf, y = Inf, label = cor_label), 
             hjust = -0.1, vjust = 1.5, inherit.aes = FALSE) + 
  theme_minimal()
```

The results are displayed in @fig-importance-penguins-by-species.


```{r}
#| label: fig-importance-penguins-by-species 
#| fig-cap: PFI by species. The results are quite similar to overal PFI and don't differ much by species.
dat = lapply(c("Adelie", "Chinstrap", "Gentoo"), function(species) {
  pred.penguins = Predictor$new(pengu_rf, data = penguins_test[penguins_test$species == species,], class="female")
  dat = FeatureImp$new(predictor, loss = "ce", compare="ratio")$results
  dat$species = species
  dat
})

dat = do.call(rbind, dat)

ggplot(dat) + 
  geom_point(aes(x = importance, y = feature, shape = species, color = species), 
             size = 3, position = position_jitter(width = 0, height = 0.2))
```


## Strengths

**Nice interpretation**: Feature importance is the increase in model error when the feature's information is destroyed.

Feature importance provides a **highly compressed, global insight** into the model's behavior.

A positive aspect of using the error ratio instead of the error difference is that the feature importance measurements are **comparable across different problems**.

The importance measure automatically **takes into account all interactions** with other features.
By permuting the feature you also destroy the interaction effects with other features.
This means that the permutation feature importance takes into account both the  main feature effect and the interaction effects on model performance.
This is also a disadvantage because the importance of the interaction between two features is included in the importance measurements of both features.
This means that the feature importances do not add up to the total drop in performance, but the sum is larger.
Only if there is no interaction between the features, as in a linear model, the importances add up approximately.

Permutation feature importance **does not require retraining the model**.
Some other methods suggest deleting a feature, retraining the model and then comparing the model error.
Since the retraining of a machine learning model can take a long time, "only" permuting a feature can save a lot of time.
Importance methods that retrain the model with a subset of features appear intuitive at first glance, but the model with the reduced data is meaningless for the feature importance.
We are interested in the feature importance of a fixed model.
Retraining with a reduced dataset creates a different model than the one we are interested in.
Suppose you train a sparse linear model (with Lasso) with a fixed number of features with a non-zero weight.
The dataset has 100 features, you set the number of non-zero weights to 5.
You analyze the importance of one of the features that have a non-zero weight.
You remove the feature and retrain the model.
The model performance remains the same because another equally good feature gets a non-zero weight and your conclusion would be that the feature was not important.
Another example:
The model is a decision tree and we analyze the importance of the feature that was chosen as the first split.
You remove the feature and retrain the model.
Since another feature is chosen as the first split, the whole tree can be very different, which means that we compare the error rates of (potentially) completely different trees to decide how important that feature is for one of the trees.

## Limitations

Permutation feature importance is **linked to the error of the model**.
This is not inherently bad, but in some cases not what you need.
In some cases, you might prefer to know how much the model's output varies for a feature without considering what it means for performance.
For example, you want to find out how robust your model's output is when someone manipulates the features.
In this case, you would not be interested in how much the model performance decreases when a feature is permuted, but how much of the model's output variance is explained by each feature.
Model variance (explained by the features) and feature importance correlate strongly when the model generalizes well (i.e. it does not overfit).

You **need access to the true outcome**.
If someone only provides you with the model and unlabeled data -- but not the true outcome -- you cannot compute the permutation feature importance.

The permutation feature importance depends on shuffling the feature, which adds randomness to the measurement.
When the permutation is repeated, the **results might vary greatly**.
Repeating the permutation and averaging the importance measures over repetitions stabilizes the measure, but increases the time of computation.

If features are correlated, the permutation feature importance **can be biased by unrealistic data instances**.
The problem is the same as with [partial dependence plots](#pdp):
The permutation of features produces unlikely data instances when two or more features are correlated.
When they are positively correlated (like height and weight of a person) and I shuffle one of the features, I create new instances that are unlikely or even physically impossible (2 meter person weighing 30 kg for example), yet I use these new instances to measure the importance.
In other words, for the permutation feature importance of a correlated feature, we consider how much the model performance decreases when we exchange the feature with values we would never observe in reality.
Check if the features are strongly correlated and be careful about the interpretation of the feature importance if they are.
However, pairwise correlations might not be sufficient to reveal the problem.

Another tricky thing:
**Adding a correlated feature can decrease the importance of the associated feature** by splitting the importance between both features.
Let me give you an example of what I mean by "splitting" feature importance:
We want to predict the probability of rain and use the temperature at 8:00 AM of the day before as a feature along with other uncorrelated features.
I train a random forest and it turns out that the temperature is the most important feature and all is well and I sleep well the next night.
Now imagine another scenario in which I additionally include the temperature at 9:00 AM as a feature that is strongly correlated with the temperature at 8:00 AM.
The temperature at 9:00 AM does not give me much additional information if I already know the temperature at 8:00 AM.
But having more features is always good, right?
I train a random forest with the two temperature features and the uncorrelated features.
Some of the trees in the random forest pick up the 8:00 AM temperature, others the 9:00 AM temperature, again others both and again others none.
The two temperature features together have a bit more importance than the single temperature feature before, but instead of being at the top of the list of important features, each temperature is now somewhere in the middle.
By introducing a correlated feature, I kicked the most important feature from the top of the importance ladder to mediocrity.
On one hand this is fine, because it simply reflects the behavior of the underlying machine learning model, here the random forest.
The 8:00 AM temperature has simply become less important because the model can now rely on the 9:00 AM measurement as well.
On the other hand, it makes the interpretation of the feature importance considerably more difficult.
Imagine you want to check the features for measurement errors.
The check is expensive and you decide to check only the top 3 of the most important features.
In the first case you would check the temperature, in the second case you would not include any temperature feature just because they now share the importance.
Even though the importance values might make sense at the level of model behavior, it is confusing if you have correlated features.


## Alternatives

An algorithm called [PIMP](https://academic.oup.com/bioinformatics/article/26/10/1340/193348) adapts the permutation feature importance algorithm to provide p-values for the importances.
Another loss-based alternative is [LOFO](#lofo), which omit the feature from the training data, retrains the model and measures the increase in loss.
Permuting a feature and measuring the increase in loss is not the only way to measure the importance of a feature.
The different importance measures can be divided into model-specific and model-agnostic methods.
The Gini importance for random forests or standardized regression coefficients for regression models are examples of model-specific importance measures.

A model-agnostic alternative to permutation feature importance are variance-based measures.
Variance-based feature importance measures such as Sobol's indices or [functional ANOVA](#decomposition) give higher importance to features that cause high variance in the prediction function.
Also [SHAP importance](#shap) has similarities to a variance-based importance measure.
If changing a feature greatly changes the output, then it is important.
This definition of importance differs from the loss-based definition as in the case of permutation feature importance.
This is evident in cases where a model overfitted.
If a model overfits and uses a feature that is unrelated to the output, then the permutation feature importance would assign an importance of zero because this feature does not contribute to producing correct predictions.
A variance-based importance measure, on the other hand, might assign the feature high importance as the prediction can change a lot when the feature is changed.

A good overview of various importance techniques is provided in the paper by Wei (2015) [@wei2015variable].

## Software

The `iml` R package was used for the examples.
The R packages `DALEX` and `vip`, as well as the Python library `alibi`, `scikit-learn` and `rfpimp`, also implement model-agnostic permutation feature importance.

